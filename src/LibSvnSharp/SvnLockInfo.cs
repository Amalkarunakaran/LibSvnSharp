using System;
using LibSvnSharp.Implementation;
using LibSvnSharp.Interop.Svn;

namespace LibSvnSharp
{
    public sealed class SvnLockInfo
    {
        svn_lock_t _lock;
        readonly bool _localData;
        string _path;
        string _fullPath;
        string _token;
        string _owner;
        string _comment;

        internal SvnLockInfo(svn_lock_t @lock, bool localData)
        {
            if (@lock == null)
                throw new ArgumentNullException(nameof(@lock));

            _localData = localData;
            _lock = @lock;
            IsRawNetworkComment = @lock.is_dav_comment;
            CreationTime = SvnBase.DateTimeFromAprTime(@lock.creation_date);
            ExpirationTime = SvnBase.DateTimeFromAprTime(@lock.expiration_date);
        }

        public unsafe string Path
        {
            get
            {
                if (_path == null && _lock != null)
                    _path = SvnBase.Utf8_PtrToString(_lock.path);

                return _path;
            }
        }

        /// <summary>The path the notification is about, translated via <see cref="SvnTools.GetNormalizedFullPath" /></summary>
        /// <remarks>The <see cref="FullPath" /> property contains the path in normalized format; while <see cref="Path" /> returns the exact path from the subversion api</remarks>
        public string FullPath
        {
            get
            {
                if (_fullPath == null && _localData && Path != null)
                    _fullPath = SvnTools.GetNormalizedFullPath(Path);

                return _fullPath;
            }
        }

        public unsafe string Token
        {
            get
            {
                if (_token == null && _lock != null)
                    _token = SvnBase.Utf8_PtrToString(_lock.token);

                return _token;
            }
        }

        public unsafe string Owner
        {
            get
            {
                if (_owner == null && _lock != null)
                    _owner = SvnBase.Utf8_PtrToString(_lock.owner);

                return _owner;
            }
        }

        public unsafe string Comment
        {
            get
            {
                if (_comment == null && _lock != null && _lock.comment != null)
                {
                    _comment = SvnBase.Utf8_PtrToString(_lock.comment);

                    if (_comment != null)
                        _comment = _comment.Replace("\n", Environment.NewLine);
                }

                return _comment;
            }
        }

        /// <summary>Gets a boolean indicating whether the Comment was generated by a Generic WebDav client</summary>
        public bool IsRawNetworkComment { get; }

        public DateTime CreationTime { get; }

        public DateTime ExpirationTime { get; }

        public void Detach()
        {
            Detach(true);
        }

        /// <summary>Serves as a hashcode for the specified type</summary>
        public override int GetHashCode()
        {
            string owner = Owner;
            string path = Path;
            return (owner != null ? owner.GetHashCode() : 0) ^ (path != null ? path.GetHashCode() : 0) ^ CreationTime.GetHashCode();
        }

        internal void Detach(bool keepProperties)
        {
            try
            {
                if (keepProperties)
                {
                    GC.KeepAlive(Path);
                    GC.KeepAlive(Token);
                    GC.KeepAlive(Owner);
                    GC.KeepAlive(Comment);
                }
            }
            finally
            {
                _lock = null;
                //base.Detach(keepProperties);
            }
        }
    }
}
